#!/usr/bin/python3 -cimport os, sys; os.execv(os.path.dirname(sys.argv[1]) + "/common/pywrap", sys.argv)
# Run this with --help to see available options for tracing and debugging
# See https://github.com/cockpit-project/cockpit/blob/main/test/common/testlib.py
# "class Browser" and "class MachineCase" for the available API.

import re
import sys
import time

import testlib
from machine.machine_core import ssh_connection

REGISTRIES_CONF = """
[registries.search]
registries = ['localhost:5000', 'localhost:6000']

[registries.insecure]
registries = ['localhost:5000', 'localhost:6000']
"""

NOT_RUNNING = ["Exited", "Stopped"]

# image names used in tests
IMG_ALPINE = "localhost/test-alpine"
IMG_ALPINE_LATEST = IMG_ALPINE + ":latest"
IMG_BUSYBOX = "localhost/test-busybox"
IMG_BUSYBOX_LATEST = IMG_BUSYBOX + ":latest"
IMG_REGISTRY = "localhost/test-registry"
IMG_REGISTRY_LATEST = IMG_REGISTRY + ":latest"


def podman_version(cls):
    version = cls.execute(False, "podman -v").strip().split(' ')[-1]
    # HACK: handle possible rc versions such as 4.4.0-rc2
    return tuple(int(v.split('-')[0]) for v in version.split('.'))


def showImages(browser):
    if browser.attr("#containers-images button.pf-v5-c-expandable-section__toggle", "aria-expanded") == 'false':
        browser.click("#containers-images button.pf-v5-c-expandable-section__toggle")


@testlib.nondestructive
class TestApplication(testlib.MachineCase):

    def setUp(self):
        super().setUp()
        m = self.machine
        m.execute("""
            systemctl stop podman.service; systemctl --now enable podman.socket
            # Ensure podman is really stopped, otherwise it keeps the containers/ directory busy
            pkill -e -9 podman || true
            while pgrep podman; do sleep 0.1; done
            pkill -e -9 conmon || true
            while pgrep conmon; do sleep 0.1; done
            findmnt --list -otarget | grep /var/lib/containers/. | xargs -r umount
            sync
            """)

        # backup/restore pristine podman state, so that tests can run on existing testbeds
        self.restore_dir("/var/lib/containers")

        self.addCleanup(m.execute, """
            systemctl stop podman.service podman.socket

            # HACK: system reset has 10s timeout, make that faster with an extra `stop`
            # https://github.com/containers/podman/issues/21874
            podman stop --time 0 --all
            podman pod stop --time 0 --all

            systemctl reset-failed podman.service podman.socket
            podman system reset --force
            pkill -e -9 podman || true
            while pgrep podman; do sleep 0.1; done
            pkill -e -9 conmon || true
            while pgrep conmon; do sleep 0.1; done

            # HACK: sometimes podman leaks mounts
            findmnt --list -otarget | grep /var/lib/containers/. | xargs -r umount
            sync
            """)

        # Create admin session
        m.execute("""
            if [ ! -d /home/admin/.ssh ]; then
                mkdir /home/admin/.ssh
                cp /root/.ssh/* /home/admin/.ssh
                chown -R admin:admin /home/admin/.ssh
                chmod -R go-wx /home/admin/.ssh
            fi
            """)
        self.admin_s = ssh_connection.SSHConnection(user="admin",
                                                    address=m.ssh_address,
                                                    ssh_port=m.ssh_port,
                                                    identity_file=m.identity_file)

        # Enable user service as well; copy our images (except cockpit/ws) from system
        self.admin_s.execute("""
            systemctl --user stop podman.service
            for img in $(ls /var/lib/test-images/*.tar | grep -v cockpitws); do podman load < "$img"; done
            systemctl --now --user enable podman.socket
            """)
        self.addCleanup(self.admin_s.execute, """
            systemctl --user stop podman.service podman.socket
            podman system reset --force
            """)
        # HACK: system reset has 10s timeout, make that faster with an extra `stop`
        # https://github.com/containers/podman/issues/21874
        # Ubuntu 22.04 has old podman that does not know about rm --time
        if m.image == 'ubuntu-2204':
            self.addCleanup(self.admin_s.execute, "podman rm --force --all", timeout=300)
            self.addCleanup(self.admin_s.execute, "podman pod rm --force --all", timeout=300)
        else:
            self.addCleanup(self.admin_s.execute, "podman rm --force --time 0 --all")
            self.addCleanup(self.admin_s.execute, "podman pod rm --force --time 0 --all")

        # But disable it globally so that "systemctl --user disable" does what we expect
        m.execute("systemctl --global disable podman.socket")

        self.allow_journal_messages("/run.*/podman/podman: couldn't connect.*")
        self.allow_journal_messages(".*/run.*/podman/podman.*Connection reset by peer")

        # https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1008249
        self.has_criu = "debian" not in m.image and "ubuntu" not in m.image
        self.has_selinux = not any(img in m.image for img in ["arch", "debian", "ubuntu", "suse"])
        self.has_cgroupsV2 = not m.image.startswith('rhel-8')

        self.system_images_count = int(self.execute(True, "podman images -n | wc -l").strip())
        self.user_images_count = int(self.execute(False, "podman images -n | wc -l").strip())

        # allow console.error
        self.allow_browser_errors(
            ".*couldn't search registry \".*\": pinging container registry .*",
            ".*Error occurred while connecting console: cannot resize session: cannot resize container.*",
        )

    def tearDown(self):
        if self.getError():
            # dump container logs for debugging
            for auth in [False, True]:
                print(f"----- {'system' if auth else 'user'} containers -----", file=sys.stderr)
                self.execute(auth, "podman ps -a >&2")
                self.execute(auth, 'for c in $(podman ps -aq); do echo "---- $c ----" >&2; podman logs $c >&2; done')

        super().tearDown()

    def performContainerAction(self, container, cmd):
        b = self.browser
        b.click(f"#containers-containers tbody tr:contains('{container}') .pf-v5-c-menu-toggle")
        b.click(f"#containers-containers tbody tr:contains('{container}') button.pf-v5-c-menu__item:contains({cmd})")

    def getContainerAction(self, container, cmd):
        return f"#containers-containers tbody tr:contains('{container}') button.pf-v5-c-menu__item:contains({cmd})"

    def toggleExpandedContainer(self, container):
        b = self.browser
        b.click(f"#containers-containers tbody tr:contains('{container}') .pf-v5-c-table__toggle button")

    def getContainerAttr(self, container, key, selector=""):
        b = self.browser
        return b.text(f"#containers-containers tbody tr:contains('{container}') > td[data-label={key}] {selector}")

    def execute(self, system, cmd):
        if system:
            return self.machine.execute(cmd)
        else:
            return self.admin_s.execute(cmd)

    def login(self, system=True):
        # HACK: The first rootless call often gets stuck or fails
        # In such case we have alert banner to start the service (or just empty state)
        # A real user would just hit the button so lets do the same as this is always getting
        # back to us and we waste too much time reporting to podman with mixed results.
        # Examples:
        #     https://github.com/containers/podman/issues/8762
        #     https://github.com/containers/podman/issues/9251
        #     https://github.com/containers/podman/issues/6660

        b = self.browser

        self.login_and_go("/podman", superuser=system)
        b.wait_visible("#app")

        with self.browser.wait_timeout(30):
            try:
                b.wait_not_in_text("#containers-containers", "Loading")
                b.wait_not_present("#overview div.pf-v5-c-alert")
            except testlib.Error:
                if system:
                    b.click("#overview div.pf-v5-c-alert .pf-v5-c-alert__action > button:contains(Start)")
                    b.wait_not_present("#overview div.pf-v5-c-alert")
                else:
                    b.click("#app .pf-v5-c-empty-state button.pf-m-primary")
                    b.wait_not_present("#app .pf-v5-c-empty-state button")

    def waitContainerRow(self, container, present=True):
        b = self.browser
        if present:
            b.wait_visible(f'#containers-containers td[data-label="Container"]:contains("{container}")')
        else:
            b.wait_not_present(f'#containers-containers td[data-label="Container"]:contains("{container}")')

    def getStartTime(self, container: str, *, auth: bool) -> str:
        # don't format the raw time strings from the API, force json format
        out = self.execute(auth, "podman inspect --format '{{json .State.StartedAt}}' " + container)
        return out.strip().replace('"', '')

    def waitRestart(self, container: str, old_start: str, *, auth: bool) -> str:
        for _ in range(10):
            new_start = self.getStartTime(container, auth=auth)
            if new_start > old_start:
                return new_start
            time.sleep(1)
        else:
            self.fail("Timed out waiting for StartedAt change")
            return ''  # quiesce mypy, not reached

    def setupRegistry(self):
        m = self.machine

        self.execute(True, f"""
            podman run -d -p 5000:5000 --name registry --stop-timeout 0 {IMG_REGISTRY}
            podman run -d -p 6000:5000 --name registry_alt --stop-timeout 0 {IMG_REGISTRY}
        """)

        # Add local insecure registry into registries conf
        m.write("/etc/containers/registries.conf", REGISTRIES_CONF)
        self.execute(True, "systemctl stop podman.service")

    def testLifecycleOperationsUser(self):
        self._testLifecycleOperations(False)

    def testLifecycleOperationsUser1(self):
        self._testLifecycleOperations(False)

    def testLifecycleOperationsUser2(self):
        self._testLifecycleOperations(False)

    def testLifecycleOperationsSystem(self):
        self._testLifecycleOperations(True)

    def testLifecycleOperationsSystem1(self):
        self._testLifecycleOperations(True)

    def testLifecycleOperationsSystem2(self):
        self._testLifecycleOperations(True)

    def testLifecycleOperationsSystem3(self):
        self._testLifecycleOperations(True)

    def testLifecycleOperationsSystem4(self):
        self._testLifecycleOperations(True)

    def testLifecycleOperationsSystem5(self):
        self._testLifecycleOperations(True)

    def _testLifecycleOperations(self, auth):
        b = self.browser

        if not auth:
            self.allow_browser_errors("Failed to start system podman.socket.*")

        self.login()
        self.filter_containers('all')

        # run a container
        self.execute(auth, f"""
                podman run -d --name swamped-crate --stop-timeout 0 {IMG_BUSYBOX} sh -c 'echo 123; sleep infinity';
                podman stop swamped-crate""")
        b.wait(lambda: self.execute(auth, "podman ps --all | grep -e swamped-crate -e Exited"))

        b.wait_visible("#containers-containers")
        container_sha = self.execute(auth, "podman inspect --format '{{.Id}}' swamped-crate").strip()
        self.waitContainer(container_sha, auth, name='swamped-crate', image=IMG_BUSYBOX,
                           state='Exited', owner="system" if auth else "admin")
        b.click("#containers-containers tbody tr:contains('swamped-crate') .pf-v5-c-menu-toggle")

        if not auth:
            # Checkpoint/restore is not supported on user containers yet - the related buttons should not be shown
            # Check that the restore option is not present
            b.wait_not_present(self.getContainerAction('swamped-crate', 'Restore'))

        # Health check is not set up
        b.wait_not_present(self.getContainerAction('swamped-crate', 'Run health check'))

        b.click("#containers-containers tbody tr:contains('swamped-crate') .pf-v5-c-menu-toggle")

        # Start the container
        self.performContainerAction(IMG_BUSYBOX, "Start")

        self.waitContainer(container_sha, auth, name='swamped-crate', image=IMG_BUSYBOX,
                           state='Running', owner="system" if auth else "admin")

        # run another container with explicit memory 400 MiB limit, with a process that uses 300 MB memory
        self.execute(
            auth,
            f"podman run -d --name picket-fence --memory 400m --stop-timeout 0 {IMG_ALPINE} "
            """awk 'BEGIN { y = sprintf("%300000000s",""); system("sleep infinity") }'""")
        picket_fence_sha = self.execute(auth, "podman inspect --format '{{.Id}}' picket-fence").strip()
        self.waitContainer(picket_fence_sha, auth, name="picket-fence", state="Running")

        def get_cpu_usage(sel):
            cpu = self.getContainerAttr(sel, "CPU")
            self.assertIn('%', cpu)
            # If it not a number it will raise ValueError which is what we want to know
            return float(cpu[:-1])

        # Check we show usage
        b.wait(lambda: self.getContainerAttr(IMG_BUSYBOX, "CPU") != "")
        b.wait(lambda: self.getContainerAttr(IMG_BUSYBOX, "Memory") != "")

        memory = self.getContainerAttr(IMG_BUSYBOX, "Memory")
        if auth or self.has_cgroupsV2:
            # Wait for CPU usage to settle before saving CPU usage for comparison later
            b.wait(lambda: get_cpu_usage(IMG_BUSYBOX) < 25)
            cpu = get_cpu_usage(IMG_BUSYBOX)

            # swamped-crate has no explicit --memory limit
            m = re.match(r'([0-9]+)%([0-9.]+) kB$', memory)
            self.assertTrue(m, memory)
            mem_pct = int(m.group(1))
            mem_abs = float(m.group(2))
            self.assertGreaterEqual(mem_pct, 0)
            self.assertGreaterEqual(mem_abs, 1.0)
            # this container doesn't do anything, should have small memory usage
            self.assertLessEqual(mem_pct, 5)
            self.assertLessEqual(mem_abs, 300.0)

            # Test that the CPU value is updated dynamically
            self.execute(auth, "podman exec -i swamped-crate sh -c 'dd bs=1024 < /dev/urandom > /dev/null &'")
            with b.wait_timeout(30):
                b.wait(lambda: get_cpu_usage(IMG_BUSYBOX) > cpu)
            self.execute(auth, "podman exec swamped-crate sh -c 'pkill dd'")

            # picket-fence has a memory limit

            # Wait for CPU usage to settle before saving memory usage
            b.wait(lambda: get_cpu_usage(IMG_BUSYBOX) < 25)

            def get_mem_usage(sel):
                memory = self.getContainerAttr(sel, "Memory")
                m = re.match(r'([0-9]+)%([0-9.]+) MB([0-9]+)% of ([0-9.]+) MB limit$', memory)
                return float(m.group(2))

            # Wait for memory to settle
            # b.wait(lambda: get_mem_usage(IMG_ALPINE) > 295)

            memory = self.getContainerAttr(IMG_ALPINE, "Memory")
            m = re.match(r'([0-9]+)%([0-9.]+) MB([0-9]+)% of ([0-9.]+) MB limit$', memory)
            self.assertTrue(m, memory)
            # wide range here, to work on custom testbeds
            host_mem_pct = int(m.group(1))
            self.assertGreater(host_mem_pct, 2)
            self.assertLess(host_mem_pct, 90)
            # this is fairly well predictable
            mem_abs = float(m.group(2))
            self.assertGreaterEqual(mem_abs, 300.0)
            self.assertLess(mem_abs, 305.0)
            limit_mem_pct = int(m.group(3))
            self.assertGreaterEqual(limit_mem_pct, 70)
            self.assertLessEqual(limit_mem_pct, 75)
            # 400 MiB limit
            self.assertEqual(m.group(4), "419")
        else:
            # No support for CGroupsV2
            self.assertEqual(self.getContainerAttr(IMG_BUSYBOX, "CPU"), "n/a")
            self.assertEqual(memory, "n/a")

        # Restart the container; there is no steady state change in the visible UI, so look for
        # a changed data-started-at attribute
        old_start = self.getStartTime("swamped-crate", auth=auth)
        b.wait_in_text(f'#containers-containers tr[data-started-at="{old_start}"]', "swamped-crate")
        self.performContainerAction(IMG_BUSYBOX, "Force restart")
        new_start = self.waitRestart("swamped-crate", old_start, auth=auth)
        b.wait_in_text(f'#containers-containers tr[data-started-at="{new_start}"]', "swamped-crate")
        self.waitContainer(container_sha, auth, name='swamped-crate', image=IMG_BUSYBOX, state='Running')

        self.waitContainerRow(IMG_BUSYBOX)
        if not auth:
            # Check that the checkpoint option is not present for rootless
            b.click(f"#containers-containers tbody tr:contains('{IMG_BUSYBOX}') .pf-v5-c-menu-toggle")
            b.wait_visible(self.getContainerAction(IMG_BUSYBOX, 'Force stop'))
            b.wait_not_present(self.getContainerAction(IMG_BUSYBOX, 'Checkpoint'))
            b.click(f"#containers-containers tbody tr:contains('{IMG_BUSYBOX}') .pf-v5-c-menu-toggle")
        # Stop the container
        self.performContainerAction(IMG_BUSYBOX, "Force stop")

        self.waitContainer(container_sha, auth, name='swamped-crate', image=IMG_BUSYBOX)
        b.wait(lambda: self.getContainerAttr("swamped-crate", "State") in NOT_RUNNING)
        b.wait(lambda: self.getContainerAttr("swamped-crate", "CPU") == "")
        b.wait(lambda: self.getContainerAttr("swamped-crate", "Memory") == "")

        # Check that container details are not lost when the container is stopped
        self.toggleExpandedContainer("swamped-crate")
        b.click(".pf-m-expanded button:contains('Integration')")
        b.wait_visible(f'#containers-containers tr:contains("{IMG_BUSYBOX}") dt:contains("Environment variables")')

        # Check that console reconnects when container starts
        b.click(".pf-m-expanded button:contains('Console')")
        b.wait_text(".pf-m-expanded .pf-v5-c-empty-state", "Container is not running")
        self.performContainerAction("swamped-crate", "Start")
        b.wait_in_text(".pf-m-expanded .xterm-accessibility-tree", "/ # ")
        b.focus(".pf-m-expanded .xterm-helper-textarea")
        b.input_text("clear")
        b.key("Enter")
        b.wait_not_in_text(".pf-m-expanded .xterm-accessibility-tree", "clear")
        b.wait_text(".pf-m-expanded .xterm-accessibility-tree > div:nth-child(1)", "/ # ")
        b.input_text('echo hello')
        b.key("Enter")
        b.wait_text(".pf-m-expanded .xterm-accessibility-tree > div:nth-child(2)", "hello")
        b.wait_text(".pf-m-expanded .xterm-accessibility-tree > div:nth-child(3)", "/ # ")
        self.performContainerAction("swamped-crate", "Stop")
        b.wait_text(".pf-m-expanded .xterm-accessibility-tree > div:nth-child(3)", "/ #  disconnected ")
        sha = self.execute(auth, "podman inspect --format '{{.Id}}' swamped-crate").strip()
        self.waitContainer(sha, auth, name='swamped-crate', image=IMG_BUSYBOX, state=NOT_RUNNING)
        self.performContainerAction("swamped-crate", "Start")
        self.waitContainer(sha, auth, state='Running')
        b.wait_text(".pf-m-expanded .xterm-accessibility-tree > div:nth-child(1)", "/ # ")
        b.wait_not_in_text(".pf-m-expanded .xterm-accessibility-tree > div:nth-child(2)", "hello")

        # Check that logs reconnect when container starts
        b.click(".pf-m-expanded button:contains('Logs')")
        self.performContainerAction("swamped-crate", "Stop")
        self.waitContainer(sha, auth, state=NOT_RUNNING)
        b.wait_in_text(".pf-m-expanded .container-logs .xterm-accessibility-tree", "Streaming disconnected")
        self.performContainerAction("swamped-crate", "Start")
        b.wait_in_text(".pf-m-expanded .container-logs .xterm-accessibility-tree", "Streaming disconnected123")

    def testCheckpointRestore(self):
        m = self.machine
        b = self.browser

        self.login()
        self.filter_containers('all')

        if not self.has_criu:
            # On cgroupsv1 systems just check that we get expected error messages

            # Run a container
            self.execute(True, f"podman run -dit --name swamped-crate --stop-timeout 0 {IMG_BUSYBOX} sh")
            b.wait(lambda: self.execute(True, "podman ps --all | grep -e swamped-crate"))

            # Checkpoint the container
            self.performContainerAction(IMG_BUSYBOX, "Checkpoint")
            b.set_checked('.pf-v5-c-modal-box input#checkpoint-dialog-keep', True)
            b.set_checked('.pf-v5-c-modal-box input#checkpoint-dialog-tcpEstablished', True)
            b.click('.pf-v5-c-modal-box button:contains(Checkpoint)')
            b.wait_not_present('.modal_dialog')

            def criu_alert():
                text = b.text(".pf-v5-c-alert.pf-m-danger > .pf-v5-c-alert__description").lower()
                return "checkpoint/restore requires at least criu" in text or "failed to check for criu" in text
            b.wait(criu_alert)
            return

        # Run a container
        mac_address = '92:d0:c6:0a:29:38'
        self.execute(True, f"""
            podman run -dit --mac-address {mac_address} --name swamped-crate --stop-timeout 0 {IMG_BUSYBOX} sh;
            podman stop swamped-crate
        """)
        b.wait(lambda: self.execute(True, "podman ps --all | grep -e swamped-crate -e Exited"))

        # Check that the restore option is not present (i.e. start is a regular button)
        b.click(f"#containers-containers tbody tr:contains('{IMG_BUSYBOX}') .pf-v5-c-menu-toggle")
        b.wait_not_present(self.getContainerAction(IMG_BUSYBOX, 'Restore'))
        b.click(f"#containers-containers tbody tr:contains('{IMG_BUSYBOX}') .pf-v5-c-menu-toggle")

        # Start the container
        self.performContainerAction("swamped-crate", "Start")
        b.wait(lambda: self.getContainerAttr("swamped-crate", "State") in 'Running')

        self.toggleExpandedContainer("swamped-crate")
        b.wait_visible(".pf-m-expanded button:contains('Details')")
        b.wait_not_present(f'#containers-containers tr:contains("{IMG_BUSYBOX}") dt:contains("Latest checkpoint")')

        # Checkpoint the container
        self.performContainerAction("swamped-crate", "Checkpoint")
        b.set_checked('.pf-v5-c-modal-box input#checkpoint-dialog-keep', True)
        b.set_checked('.pf-v5-c-modal-box input#checkpoint-dialog-tcpEstablished', True)
        b.click('.pf-v5-c-modal-box button:contains(Checkpoint)')

        with b.wait_timeout(300):
            b.wait_not_present(".pf-v5-c-modal-box")

        if self.has_criu:
            b.wait(lambda: self.getContainerAttr("swamped-crate", "State") in NOT_RUNNING)
            b.wait_in_text(
                f'#containers-containers tr:contains("{IMG_BUSYBOX}") dt:contains("Latest checkpoint") + dd',
                'today at'
            )
        else:
            # expect proper error message
            b.wait_in_text(".pf-v5-c-alert.pf-m-danger", "Failed to checkpoint container swamped-crate")
            b.wait(lambda: "checkpoint/restore requires at least criu" in
                   b.text(".pf-v5-c-alert.pf-m-danger > .pf-v5-c-alert__description").lower())
            return

        # Restore the container
        self.waitContainerRow("swamped-crate")
        self.performContainerAction("swamped-crate", "Restore")
        b.set_checked('.pf-v5-c-modal-box input#restore-dialog-keep', True)
        b.set_checked('.pf-v5-c-modal-box input#restore-dialog-tcpEstablished', True)
        b.set_checked('.pf-v5-c-modal-box input#restore-dialog-ignoreStaticIP', True)
        b.set_checked('.pf-v5-c-modal-box input#restore-dialog-ignoreStaticMAC', True)
        b.click('.pf-v5-c-modal-box button:contains(Restore)')
        b.wait(lambda: self.getContainerAttr("swamped-crate", "State") in 'Running')

        # A new MAC address should have been generated
        # Fixed in podman 4.4.0 https://github.com/containers/podman/issues/16666
        cmd = "podman inspect --format '{{.NetworkSettings.MacAddress}}' swamped-crate"
        new_mac_address = self.execute(True, cmd).strip()
        if podman_version(self) >= (4, 4, 0):
            self.assertNotEqual(new_mac_address, mac_address)
        else:
            self.assertEqual(new_mac_address, mac_address)

        # Checkpoint the container without stopping
        self.waitContainerRow("swamped-crate")
        self.performContainerAction("swamped-crate", "Checkpoint")
        b.set_checked('.pf-v5-c-modal-box input#checkpoint-dialog-leaveRunning', True)
        b.click('.pf-v5-c-modal-box button:contains(Checkpoint)')
        b.wait_not_present('.modal_dialog')

        # Stop the container
        m.execute("podman stop swamped-crate")
        b.wait(lambda: self.getContainerAttr("swamped-crate", "State") in NOT_RUNNING)

        # Restore the container
        self.performContainerAction("swamped-crate", "Restore")
        b.click('.pf-v5-c-modal-box button:contains(Restore)')
        b.wait(lambda: self.getContainerAttr("swamped-crate", "State") in 'Running')

    def testNotRunning(self):
        b = self.browser

        def disable_system():
            self.execute(True, "systemctl disable --now podman.socket; systemctl stop podman.service")

        def enable_system():
            self.execute(True, "systemctl enable --now podman.socket")

        def enable_user():
            self.execute(False, "systemctl --user enable --now podman.socket")

        def disable_user():
            self.execute(False, "systemctl --user disable --now podman.socket")

        def is_active_system(string):
            b.wait(lambda: self.execute(True, "systemctl is-active podman.socket || true").strip() == string)

        def is_enabled_system(string):
            b.wait(lambda: self.execute(True, "systemctl is-enabled podman.socket || true").strip() == string)

        def is_active_user(string):
            b.wait(lambda: self.execute(False, "systemctl --user is-active podman.socket || true").strip() == string)

        def is_enabled_user(string):
            b.wait(lambda: self.execute(False, "systemctl --user is-enabled podman.socket || true").strip() == string)

        disable_system()
        disable_user()
        self.login_and_go("/podman")

        # Troubleshoot action
        b.click("#app .pf-v5-c-empty-state button.pf-m-link")
        b.enter_page("/system/services")
        # services page is too slow
        with b.wait_timeout(60):
            b.wait_in_text("#service-details", "podman.socket")

        # Start action, with enabling (by default)
        b.go("/podman")
        b.enter_page("/podman")
        b.click("#app .pf-v5-c-empty-state button.pf-m-primary")

        b.wait_visible("#containers-containers")
        b.wait_not_present("#overview div.pf-v5-c-alert.pf-m-info")

        is_active_system("active")
        is_active_user("active")
        is_enabled_system("enabled")
        is_enabled_user("enabled")

        # Start action, without enabling
        disable_system()
        disable_user()
        b.click("#app .pf-v5-c-empty-state input[type=checkbox]")
        b.assert_pixels("#app .pf-v5-c-empty-state", "podman-service-disabled", skip_layouts=["medium", "mobile"])
        b.click("#app .pf-v5-c-empty-state button.pf-m-primary")

        b.wait_visible("#containers-containers")
        is_enabled_system("disabled")
        is_enabled_user("disabled")
        is_active_system("active")
        is_active_user("active")

        b.logout()
        disable_system()
        # HACK: Due to https://github.com/containers/podman/issues/7180, avoid
        # user podman.service to time out; make sure to start it afresh
        disable_user()
        enable_user()
        self.login_and_go("/podman")
        b.wait_in_text("#overview div.pf-v5-c-alert .pf-v5-c-alert__title", "System Podman service is also available")
        b.click("#overview div.pf-v5-c-alert .pf-v5-c-alert__action > button:contains(Start)")
        b.wait_not_present("#overview div.pf-v5-c-alert")
        is_active_system("active")
        is_active_user("active")
        is_enabled_user("enabled")
        is_enabled_system("enabled")

        b.logout()
        disable_user()
        enable_system()
        self.login_and_go("/podman")
        b.wait_in_text("#overview div.pf-v5-c-alert .pf-v5-c-alert__title", "User Podman service is also available")
        b.click("#overview div.pf-v5-c-alert .pf-v5-c-alert__action > button:contains(Start)")
        b.wait_not_present("#overview div.pf-v5-c-alert")
        is_active_system("active")
        is_active_user("active")
        is_enabled_user("enabled")
        is_enabled_system("enabled")

        b.logout()
        disable_user()
        disable_system()
        self.login_and_go("/podman", superuser=False)
        b.click("#app .pf-v5-c-empty-state button.pf-m-primary")
        b.wait_visible("#containers-containers")
        b.wait_not_present("#overview div.pf-v5-c-alert")

        is_active_system("inactive")
        is_active_user("active")
        is_enabled_user("enabled")
        is_enabled_system("disabled")
        b.logout()

        # no Troubleshoot action without cockpit-system package
        disable_system()
        disable_user()
        self.restore_dir("/usr/share/cockpit/systemd")
        self.machine.execute("rm /usr/share/cockpit/systemd/manifest.json")
        self.login_and_go("/podman")
        b.wait_visible("#app .pf-v5-c-empty-state button.pf-m-primary")
        self.assertFalse(b.is_present("#app .pf-v5-c-empty-state button.pf-m-link"))
        # starting still works
        b.click("#app .pf-v5-c-empty-state button.pf-m-primary")
        b.wait_visible("#containers-containers")

        self.allow_restart_journal_messages()
        self.allow_journal_messages(".*podman/podman.sock/.*: couldn't connect:.*")
        self.allow_journal_messages(".*podman/podman.sock: .*Connection.*Error.*")
        self.allow_journal_messages(".*podman/podman.sock/.*/events.*: received truncated HTTP response.*")

    def filter_containers(self, value):
        """Use dropdown menu in the header to filter containers"""
        b = self.browser
        b.set_val("#containers-containers-filter", value)

    def confirm_modal(self, text):
        """Wait for the pop up window and click the button with text"""
        b = self.browser
        b.click(f".pf-v5-c-modal-box footer button:contains({text})")
        b.wait_not_present(f".pf-v5-c-modal-box footer button:contains({text})")

    def waitContainer(self, row_id, auth, name="", image="", cmd="", owner="", state=None, pod="no-pod"):
        """Check the container with row_name has the expected values
            "image" can be substring, "state" might be string or array of possible states, other are
            checked for exact match.
        """
        sel = "#containers-containers #table-" + pod + f" tbody tr[data-row-id=\"{row_id}{auth}\"]".lower()
        b = self.browser
        if name:
            b.wait_text(sel + " .container-name", name)
        if image:
            b.wait_in_text(sel + " td[data-label=Container] small:nth-child(2)", image)
        if cmd:
            b.wait_text(sel + " td[data-label=Container] small:last-child", cmd)
        if owner:
            if owner == "system":
                b.wait_text(sel + " td[data-label=Owner]", owner)
            else:
                b.wait_text(sel + " td[data-label=Owner]", "user: " + owner)
        if state is not None:
            if not isinstance(state, list):
                state = [state]
            b.wait(lambda: b.text(sel + " td[data-label=State]") in state)


if __name__ == '__main__':
    testlib.test_main()
